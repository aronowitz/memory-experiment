group_by(time) %>%
pairwise_t_test(score ~ group, p.adjust.method = 'bonferroni')
one.way2 <- anxiety %>%
group_by(group) %>%
anova_test(dv = score, wid = id, within = time) %>%
get_anova_table() %>%
adjust_pvalue(method = 'bonferroni')
pwc2 <- anxiety %>%
group_by(group) %>%
pairwise_t_test(score ~ time, paired = TRUE, p.adjust.method = 'bonferroni') %>%
select(-df, -statistic, -p)
# Non-significant two-way interaction
anxiety %>%
pairwise_t_test(score ~ time, paired = TRUE, p.adjust.method = 'bonferroni')
anxiety %>%
pairwise_t_test(score ~ group, p.adjust.method = 'bonferroni')
### REPORT
pwc <- pwc %>% add_xy_position(x = 'time')
pwc.filtered <- pwc %>% filter(time != 't1')
pwc.filtered
head(as.data.frame(pwc.filtered))
library(tidyverse)
library(ggpubr)
library(rstatix)
##### TWO-WAY MIXED ANOVA
set.seed(123)
data('anxiety', package = 'datarium')
dat <- as.data.frame(anxiety)
anxiety %>% sample_n_by(group, size = 1)
anxiety <- anxiety %>%
gather(key = 'time', value = 'score', t1, t2, t3) %>%
convert_as_factor(id, time)
dat2 <- reshape(dat, varying = list(3:5), idvar = 'id', v.names = 'score',
times = paste0('t', 1:3), timevar = 'time', direction  = 'long')
dat2$time <- factor(dat2$time)
row.names(dat2) <- 1:nrow(dat2)
dat2$int <- interaction(dat2[, 2:3])
groups <- setNames(do.call(rbind.data.frame, strsplit(levels(dat2$int), '[.]')), c('group', 'time'))
k <- lapply(lapply(levels(dat2$int), function(z) subset(dat2, int == z)), '[[', 'score')
k1 <- lapply(levels(dat2$time), function(z) subset(dat2, time == z))
k2 <- lapply(levels(dat2$group), function(z) subset(dat2, group == z))
set.seed(123)
anxiety %>% sample_n_by(group, time, size = 1)
### SUMMARY STATS
anxiety %>%
group_by(time, group) %>%
get_summary_stats(score, type = 'mean_sd')
psych::describeBy(dat2$score, dat2[, 2:3], mat = T)
bxp <- ggboxplot(anxiety, x = 'time', y = 'score', color = 'group', palette = 'jco')
### CHECK ASSUMPTIONS
# Outliers
anxiety %>%
group_by(time, group) %>%
identify_outliers(score)
outs <- lapply(k, outliers)
# Normality
anxiety %>%
group_by(time, group) %>%
shapiro_test(score)
normals <- cbind.data.frame(groups, statistic = sapply(k, function(z) shapiro.test(z)[[1]]),
p = sapply(k, function(z) shapiro.test(z)[[2]]))
ggqqplot(anxiety, 'score', ggtheme = theme_bw()) +
facet_grid(time ~ group)
# Homogeneity of variance
anxiety %>%
group_by(time) %>%
levene_test(score ~ group)
lapply(k1, function(z) car::leveneTest(z$score, z$group))
# Homogeneity of covariance
rstatix::box_m(anxiety[, 'score', drop = FALSE], anxiety$group)
# Sphericity -- automatically detected by anova_test (ges) greenhouse-geisser
### MODEL FITTING
res.aov <- anova_test(data = anxiety, dv = score, wid = id,
between = group, within = time)
get_anova_table(res.aov)
### POST-HOC TESTS
# Significant two-way interaction
one.way <- anxiety %>%
group_by(time) %>%
anova_test(dv = score, wid = id, between = group) %>%
get_anova_table() %>%
adjust_pvalue(method = 'bonferroni')
pwc <- anxiety %>%
group_by(time) %>%
pairwise_t_test(score ~ group, p.adjust.method = 'bonferroni')
one.way2 <- anxiety %>%
group_by(group) %>%
anova_test(dv = score, wid = id, within = time) %>%
get_anova_table() %>%
adjust_pvalue(method = 'bonferroni')
pwc2 <- anxiety %>%
group_by(group) %>%
pairwise_t_test(score ~ time, paired = TRUE, p.adjust.method = 'bonferroni') %>%
select(-df, -statistic, -p)
# Non-significant two-way interaction
anxiety %>%
pairwise_t_test(score ~ time, paired = TRUE, p.adjust.method = 'bonferroni')
anxiety %>%
pairwise_t_test(score ~ group, p.adjust.method = 'bonferroni')
### REPORT
pwc <- pwc %>% add_xy_position(x = 'time')
pwc.filtered <- pwc %>% filter(time != 't1')
bxp + stat_pvalue_manual(pwc.filtered, tip.length = 0, hide.ns = TRUE) +
labs(subtitle = get_test_label(res.aov, detailed = TRUE), caption = get_pwc_label(pwc))
?stat_pvalue_manual
nova
x = emails()
x
emails
x = emails('is from:me')
x
x = emails('is from:me', 1)
x
emails
x = emails('is from:me', y = 1)
rprof()
library(sos); findFn("{power analysis} mixed simulation")
install.packages('sos')
library(sos); findFn("{power analysis} mixed simulation")
library(powerlmm)
install.packages('powerlmm')
library(powerlmm)
p <- study_parameters(n1 = 11,
n2 = 5,
n3 = 4,
icc_pre_subject = 0.5,
icc_pre_cluster = 0,
var_ratio = 0.03,
icc_slope = 0.05,
effect_size = cohend(-0.8))
p
get_power(p)
n2 = per_treatment(control = 10, treatment = 20)
n2
per_treatment
vignette(package = 'powerlmm')
p1 <- study_parameters(n1 = 11,
n2 = 25,
sigma_subject_intercept = 1.44,
sigma_subject_slope = 0.2,
sigma_error = 1.44,
effect_size = cohend(-0.5,
standardizer = "pretest_SD"))
p1
>study_parameters()
>study_parameters
?study_parameters
library(powerSim)
install.packages('powerSim')
install.packages('clusterPower')
library(clusterPower)
hp('clusterPower')
file.edit('~/R/anovaPwr.R')
library(rciSC)
install.packages('rciSC')
library(scan)
install.packages('scan')
library(scan)
install.packages('scan ')
install.packages('scan')
install.packages('scan', dep = T)
hp('scan')
help(package = 'scan')
install.packages('scan', repos = c('http://R-Forge.R-project.org', 'https://cloud.r-project.org/'), dependencies = TRUE)
library(devtools)
library(roxygen2)
dir()
create('myfirstpackage')
dir()
dir('myfirstpackage/')
dir()
dir()
dir()
library(simr)
hp('simr')
simdata
head(simdata)
out1 = makeCovs(10, 3, 2, 5)
source('~/R/simr/powerFunctions.R')
out1 = makeCovs(10, 3, 2, 5)
head(out1)
dim(out1)
excoefs()
m1 = makeLmer(y ~ treat * time + (1|class/id), fixef = fixed, VarCorr = rand, sigma = res, data = out1)
colnames(out1)
data
data = matrix(1:12, 3, 4)
data
ncol(data)
form0 <- 'y ~ treat * time + (1|'
form1 <- ifelse(ncol(data) > 3, 'class/id', 'id')
form <- paste0(form0, form1, ')')
form
if(identical(form, 'default')){
form0 <- 'y ~ treat * time + (1|'
form1 <- ifelse(ncol(data) > 3, 'class/id', 'id')
form <- paste0(form0, form1, ')')
}
# makeMod
makeMod <- function(data, fixed, rand, sigma = 1, form = 'default'){
cols <- c('id', 'treat', 'time')
colnames(data) <- tolower(colnames(data))
stopifnot(all(cols %in% colnames(data)))
if(identical(form, 'default')){
form0 <- 'y ~ treat * time + (1|'
form1 <- ifelse(ncol(data) > 3, 'class/id', 'id')
form <- paste0(form0, form1, ')')
}
form <- as.formula(form)
out <- simr::makeLmer(formula = form, fixef = fixed,
VarCorr = rand, sigma = sigma,
data = data)
return(out)
}
rmall()
source('~/R/simr/powerFunctions.R')
out1 = makeCovs(10, 3, 2, 5)
excoefs()
m1 = makeMod(out1, fixed, rand, 2)
m1
sim = powerSim(m1, nsim = 100, test = fcompare(y ~ time))
sim
m1 = makeMod(out1, fixed, rand, 1)
sim = powerSim(m1, nsim = 100, test = fcompare(y ~ time))
sim
out1 = makeCovs(10, 3, 2)
out1
m1 = makeMod(out1, fixed, rand[1])
m1
# makeMod
makeMod <- function(data, fixed, rand, sigma = 2, form = 'default'){
cols <- c('id', 'treat', 'time')
colnames(data) <- tolower(colnames(data))
stopifnot(all(cols %in% colnames(data)))
if(identical(form, 'default')){
form0 <- 'y ~ treat * time + (1|'
form1 <- ifelse(ncol(data) > 3, 'class/id', 'id')
form <- paste0(form0, form1, ')')
}
form <- as.formula(form)
out <- simr::makeLmer(formula = form, fixef = fixed,
VarCorr = rand, sigma = sigma,
data = data)
return(out)
}
m1
m1
m1 = makeMod(out1, fixed, rand[1])
sim = powerSim(m1, nsim = 100, test = fcompare(y ~ time))
sim
m1
out1 = makeCovs(20, 3, 2)
out1
m1 = makeMod(out1, fixed, rand[1])
sim = powerSim(m1, nsim = 100, test = fcompare(y ~ time))
sim
out1
out1 = makeCovs(40, 3, 2)
sim = powerSim(m1, nsim = 100, test = fcompare(y ~ time))
params(4)
fixed = params(4)
# makeCovs: create data frame of covariates
makeCovs <- function(n, time, treat = 3, classes = NULL){
stopifnot(length(n) == 1); stopifnot(is.numeric(n))
stopifnot(length(time) == 1); stopifnot(is.numeric(time))
if(length(treat) == 1 & is.numeric(treat)){treat <- LETTERS[1:treat]}
stopifnot(!is.numeric(treat))
k <- n/length(treat)
while(!identical(k, round(k))){
n <- n + 1
k <- n/length(treat)
}
id <- factor(1:n)
time <- factor(1:time)
id2 <- rep(id, length(time))
time2 <- rep(time, each = length(id))
treat2 <- rep(rep(treat, each = k), length(time))
covs <- data.frame(id = id2, treat = treat2, time = time2)
if(!is.null(classes)){
if(length(classes) == 1 & is.numeric(classes)){
classes <- letters[1:classes]
}
if(!is.numeric(classes)){
kk <- length(classes)
classes <- rep(classes, each = nrow(covs))
covs <- data.frame(id = rep(id2, kk), class = classes,
treat = rep(treat2, kk),
time = rep(time2, kk))
covs <- covs[order(covs$time), ]
rownames(covs) <- 1:nrow(covs)
}
}
covs
}
out1 = makeCovs(20, 4, 3)
out1
m1 = makeMod(out1, fixed, list(.5), 2)
head(out1)
fixe
fixed
levels(out1$treat)
names(fixed) = NULL
m1 = makeMod(out1, fixed, list(.5), 2)
m1
# makeMod
makeMod <- function(data, fixed, rand, sigma = 2, form = 'default'){
cols <- c('id', 'treat', 'time')
colnames(data) <- tolower(colnames(data))
stopifnot(all(cols %in% colnames(data)))
if(identical(form, 'default')){
form0 <- 'y ~ treat * time + (1|'
form1 <- ifelse(ncol(data) > 3, 'class/id', 'id')
form <- paste0(form0, form1, ')')
}
form <- as.formula(form)
names(fixed) <- NULL; names(rand) <- NULL
out <- simr::makeLmer(formula = form, fixef = fixed,
VarCorr = rand, sigma = sigma,
data = data)
return(out)
}
fixed = params(4)
m1 = makeMod(out1, fixed, list(.5), 2)
sim = powerSim(m1, nsim = 100, test = fcompare(y ~ time))
sim
out1
out1 = makeCovs(10, 3, 2, 5)
excoefs()
fixed
fixed2 = fixed
fixed2[1] = 0
fixed2
m1 = makeMod(out1, fixed, rand, 2)
m2 = makeMod(out1, fixed2, rand, 2)
set.seed(1)
sim1 = powerSim(m1, nsim = 100, test = fcompare(y ~ time))
sim1
set.seed(1)
sim2 = powerSim(m2, nsim = 100, test = fcompare(y ~ time))
sim2
fixed
fixed[2] = .5
rmall()
source('~/R/simr/powerFunctions.R')
params(T)
m1 = makeMod(data, fixed, rand, 2)
set.seed91
set.seed(1)
sim = powerSim(m1, nsim = 100, test = fcompare(y ~ time))
fixed <- params(4)
out1 <- makeCovs(100, 4)
sim
m1 = makeMod(out1, fixed, list(.5), 2)
sim = powerSim(m1, nsim = 100, test = fcompare(y ~ time))
sim
fixed <- params(4)
out1 <- makeCovs(100, 4, classes = 4)
m1 = makeMod(out1, fixed, list(.5, .1), 2)
sim = powerSim(m1, nsim = 100, test = fcompare(y ~ time))
sim
out1 <- makeCovs(30, 4, classes = 4)
m1 = makeMod(out1, fixed, list(.5, .1), 2)
sim = powerSim(m1, nsim = 100, test = fcompare(y ~ time))
sim
fixed
out1
subset(out1, class == 'A')
head(out1)
subset(out1, class == 'a')
k = subset(out1, class == 'a')
count(k$time)
fixed
fixed = rep(.2, 12)
out1 <- makeCovs(30, 4, classes = 4)
m1 = makeMod(out1, fixed, list(.5, .1), 2)
sim = powerSim(m1, nsim = 100, test = fcompare(y ~ time))
sim
fixed = rep(.4, 12)
m1 = makeMod(out1, fixed, list(.5, .1), 2)
sim = powerSim(m1, nsim = 100, test = fcompare(y ~ time))
sim
fixed <- params(4)
out1 <- makeCovs(30, 4, classes = 4)
m1 = makeMod(out1, fixed, list(.5, .1), 2)
sim = powerSim(m1, nsim = 100, test = fcompare(y ~ time))
sim
sim
out1
fixed
fixed = rep(.4, 12)
m1 = makeMod(out1, fixed, list(.5, .1), 2)
sim = powerSim(m1, nsim = 100, test = fcompare(y ~ time))
sim
out1 <- makeCovs(50, 4, classes = 4)
m1 = makeMod(out1, fixed, list(.5, .1), 2)
sim = powerSim(m1, nsim = 100, test = fcompare(y ~ time))
sim
out1
dim(subset(out1, class == 'a'))
dim(subset(out1, class == 'a'))/4
subset(out1, class == 'a')
subset(out1, class == 'a' & time == 1)
dim(subset(out1, time == 1))
out1
k = subset(out1, time == 1)
count(k$treat)
68 * 3
200/3
### SIMPLE RANDOMIZATION
set.seed(888)
treatment <- c('A', 'B')
simple.list <- sample(treatment, 20, replace = TRUE)
cat(simple.list, sep = '\n')
table(simple.list)
library(blockrand)
set.seed(888)
block.list <- blockrand(n = 20, num.levels = 2, block.sizes = c(2, 2))
block.list
block.list2 <- blockrand(n = 20, num.levels = 2, block.sizes = c(1, 2))
block.list2
### STRATIFIED RANDOMIZATION
# Balance in patient characteristics may not be achieved in small studies
# Common strata: age, group, etc.
# Generate randomized list for each stratum
over50.severe.list <- blockrand(n = 100, num.levels = 2,
block.sizes = c(1, 2, 3, 4),
stratum = 'Over 50 Severe',
id.prefix = 'O50_S',
block.prefix = 'O50_S')
over50.severe.list
library(simr)
simr:::glmerSet
setwd('Documents/memory-experiment/DATA/final')
file.edit('finalAnalysis.R')
source('extractData.R')
out <- getData(getJSONS(), matchPs = TRUE)
sorts <- lapply(out, lapply, getSorts)
sorts$dat1 <- lapply(sorts$dat1, function(z){
z1 <- z[-(1:18), ]
z1$trial <- z1$trial - 2
return(z1)
})
simple <- lapply(sorts, function(z){
k <- seq(1, unique(sapply(z, nrow)), by = 9)
lapply(z, function(i) i[k, 1:3])
})
### Create datasets:
# Full data: all items, all IDs, all trials, all conditions
# Simple data: all IDs, all trials, all conditions
for(i in 1:3){
for(j in 1:length(sorts[[i]])){
sorts[[i]][[j]] <- cbind.data.frame(ID = j, sorts[[i]][[j]])
simple[[i]][[j]] <- cbind.data.frame(ID = j, simple[[i]][[j]])
}
sorts[[i]] <- data.frame(do.call(rbind, sorts[[i]]))
simple[[i]] <- data.frame(do.call(rbind, simple[[i]]))
}
sorts$dat2$trial <- sorts$dat2$trial + 30
simple$dat2$trial <- simple$dat2$trial + 30
sorts$dat3$trial <- sorts$dat3$trial + 60
simple$dat3$trial <- simple$dat3$trial + 60
for(i in 1:3){
sorts[[i]] <- data.frame(ID = sorts[[i]]$ID, session = i, sorts[[i]][, -1])
simple[[i]] <- data.frame(ID = simple[[i]]$ID, session = i, simple[[i]][, -1])
}
sorts <- data.frame(do.call(rbind, sorts))
simple <- data.frame(do.call(rbind, simple))
for(i in c('ID', 'session', 'condition')){
sorts[[i]] <- factor(sorts[[i]])
simple[[i]] <- factor(simple[[i]])
}
conditions <- c('SpaceSemTime', 'SpaceTime', 'SpaceSem', 'TimeSem', 'Control')
levels(sorts$condition) <- rev(levels(sorts$condition))
sorts$condition <- as.numeric(as.character(sorts$condition))
sorts$condition <- factor(sorts$condition)
levels(sorts$condition) <- rev(conditions)
levels(simple$condition) <- rev(levels(simple$condition))
simple$condition <- as.numeric(as.character(simple$condition))
simple$condition <- factor(simple$condition)
levels(simple$condition) <- rev(conditions)
sorts$correct <- sorts$correct/9
simple$correct <- simple$correct/9
rownames(sorts) <- 1:nrow(sorts)
rownames(simple) <- 1:nrow(simple)
# write.csv(sorts, 'fullData.csv', row.names = FALSE)
# write.csv(simple, 'simpleData.csv', row.names = FALSE)
### ------------------------------------------------------------------------ ###
### ------------------------------- ANALYSES ------------------------------- ###
### ------------------------------------------------------------------------ ###
### Analysis 1: Simple dataset
if(!require(lme4)){install.packages('lme4', dependencies = TRUE)} # v1.1-19
if(!require(lsmeans)){install.packages('lsmeans', dependencies = TRUE)}
m0 <- lmer(correct ~ condition + (1|ID) + (1|session),
data = simple, REML = FALSE)
m1 <- lmer(correct ~ trial + (1|ID) + (1|session),
data = simple, REML = FALSE)
m2 <- lmer(correct ~ condition + trial + (1|ID) + (1|session),
data = simple, REML = FALSE)
m3 <- lmer(correct ~ condition * trial + (1|ID) + (1|session),
data = simple, REML = FALSE)
anova(m0, m2) # Is condition necessary, or only trial?
anova(m1, m2) # Is trial necessary, or only condition?
anova(m2, m3) # Are there interactions between trial and condition?
lsmeans(m2, pairwise ~ condition, adjust = 'tukey')
lsmeans(m2, pairwise ~ condition, adjust = 'none')
lsmeans(m2, pairwise ~ condition, adjust = 'tukey')
sessionInfo()
lsmeans(m2, pairwise ~ condition, adjust = 'tukey')
1/9
k = subset(simple, session == 1)
head(k)
psych::describeBy(k$correct, k$condition, mat = T)
